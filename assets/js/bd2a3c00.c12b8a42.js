"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8933],{8570:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(79);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=u(n),h=i,p=d["".concat(l,".").concat(h)]||d[h]||m[h]||o;return n?a.createElement(p,r(r({ref:t},c),{},{components:n})):a.createElement(p,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5792:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var a=n(7626),i=(n(79),n(8570));const o={sidebar_position:3},r="Migrations",s={unversionedId:"local-storage/migrations",id:"local-storage/migrations",title:"Migrations",description:"Every schema change requires a migration, including the initial one. When you increment your schema version number and run the Verdant generate CLI, it will automatically generate the migration files for you and create a copy of your schema for use in future migrations.",source:"@site/docs/local-storage/migrations.md",sourceDirName:"local-storage",slug:"/local-storage/migrations",permalink:"/docs/local-storage/migrations",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Generating the client code",permalink:"/docs/local-storage/generate-client"},next:{title:"Indexes & Querying",permalink:"/docs/local-storage/querying"}},l={},u=[{value:"Automatic migrations",id:"automatic-migrations",level:2},{value:"What you can do in a migration",id:"what-you-can-do-in-a-migration",level:2},{value:"Understanding how migrations are run",id:"understanding-how-migrations-are-run",level:2},{value:"Supplying migrations to the client",id:"supplying-migrations-to-the-client",level:2},{value:"Migration shortcuts",id:"migration-shortcuts",level:2},{value:"Deleting old migrations",id:"deleting-old-migrations",level:3},{value:"Handling failures",id:"handling-failures",level:4}],c={toc:u};function m(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"migrations"},"Migrations"),(0,i.kt)("p",null,"Every schema change requires a migration, including the initial one. When you increment your schema version number and run the ",(0,i.kt)("inlineCode",{parentName:"p"},"Verdant generate")," CLI, it will automatically generate the migration files for you and create a copy of your schema for use in future migrations."),(0,i.kt)("p",null,"By default this migration is very minimal and possibly incorrect. It iterates over all document collections and refreshes every item. This is sufficient for applying defaults to any new created fields and updating indexes, but will not be enough if you change the shape of your data in a meaningful way."),(0,i.kt)("p",null,"You can then edit this migration to include transformation of object shapes to coincide with the schema changes, or to initialize default data for new collections, etc."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// migrations/v1.ts\n\nimport { migrate } from '@verdant-web/store';\nimport v1Schema from '../generatedClient/schemaVersions/v1.js';\nimport v2Schema from '../generatedClient/schemaVersions/v2.js';\n\nexport default migrate(v1Schema, v2Schema, async (tools) => {\n    // your migration logic goes here\n});\n")),(0,i.kt)("h2",{id:"automatic-migrations"},"Automatic migrations"),(0,i.kt)("p",null,"If no migration procedure is supplied (i.e. the migration is empty), all collections which had minor changes will receive an automatic upgrade. This can save you some trouble. Automatic migrations support the following changes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Adding a new index"),(0,i.kt)("li",{parentName:"ul"},"Changing an existing index"),(0,i.kt)("li",{parentName:"ul"},"Removing an existing index"),(0,i.kt)("li",{parentName:"ul"},"Adding a new default value"),(0,i.kt)("li",{parentName:"ul"},"Removing fields or sub-fields")),(0,i.kt)("p",null,"If your schema changes consist only of these kinds of modifications, you don't need to modify the generated migration!"),(0,i.kt)("h2",{id:"what-you-can-do-in-a-migration"},"What you can do in a migration"),(0,i.kt)("p",null,"The argument supplied to your function passed to the 2nd/3rd parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"migrate")," supplies some tools for you to migrate and initialize data."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"migrate(collectionName, async (old) => updated)"),": This takes a collection name and a processor function which receives an old document and returns a new one. You can use this to easily iterate over all existing documents and transform them however you like. You can also run async code in the iterator if you need to lookup information to change the document. In addition to your supplied modifications, each document processed by ",(0,i.kt)("inlineCode",{parentName:"li"},"migrate")," will have ",(0,i.kt)("a",{parentName:"li",href:"#automatic&20migrations"},"automatic migrations")," applied."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"queries"),": a kit of queries, namespaced by document collection. These are the same as the queries on the main client, but (currently) lack rich TypeScript hints. Use them like: ",(0,i.kt)("inlineCode",{parentName:"li"},"const matches = await queries.todos.findAll({ where: 'category', equals: 'code' });"),". Instead of a LiveQuery, the result is returned directly (no need for ",(0,i.kt)("inlineCode",{parentName:"li"},".resolved"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mutations"),": a kit of mutations, namespaced by document collection. These allow you to ",(0,i.kt)("inlineCode",{parentName:"li"},"put")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"delete")," whole documents. In contrast to ",(0,i.kt)("inlineCode",{parentName:"li"},"mutate"),", which only works with existing data, this lets you initialize new default data or remove unwanted data for the new schema.")),(0,i.kt)("p",null,"You can combine these tools with your own asynchronous logic! You can even make HTTP requests to a server to fetch initial data."),(0,i.kt)("p",null,"However, keep in mind that until migration completes, your client will not be available and your application will be in a loading state."),(0,i.kt)("h2",{id:"understanding-how-migrations-are-run"},"Understanding how migrations are run"),(0,i.kt)("p",null,"Unlike centralized server databases, migrations are not done during a set maintenance period or deploy. Any migration you create could be run at any time on anyone's device! ",(0,i.kt)("strong",{parentName:"p"},"A new user will run all your migrations before they start using the app, no matter when they find it.")," This means if a major version change alters the way Verdant does migrations, you may need to update ",(0,i.kt)("em",{parentName:"p"},"all")," your previous migrations to use the new syntax. I will try to avoid that!"),(0,i.kt)("p",null,"It's especially important to understand this new mental model for migrations if you make external requests as part of your migration / data initialization process. If you have a migration that's a year old and depends on an API on your server for data, you must not assume that because it's a year old you can safely remove that API endpoint. New users will still call that migration."),(0,i.kt)("p",null,"Likewise, if you're using any possibly flaky external data call in your migrations, ",(0,i.kt)("strong",{parentName:"p"},"you should define an explicit failure behavior.")," Do you want to continue on without that data? Or do you want to throw an error, which will crash your application? Since migrations are run first-thing, you want to be careful here! A failing migration will prevent anyone from trying your app for the first time (but existing users will not encounter this, unless they use a new device)."),(0,i.kt)("h2",{id:"supplying-migrations-to-the-client"},"Supplying migrations to the client"),(0,i.kt)("p",null,"In addition to migration files, a ",(0,i.kt)("inlineCode",{parentName:"p"},"migrations.ts")," file is generated which combines them in an array. This array of migrations (in order of version) must be supplied to the client when generated."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"// migrations/migrations.ts\nimport v1 from './migrations/v1.js';\n\nexport default [v1];\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import migrations from './migrations/migrations.js';\n\nconst clientDesc = new ClientDescriptor({\n    // ... the rest\n    migrations,\n});\n")),(0,i.kt)("h2",{id:"migration-shortcuts"},"Migration shortcuts"),(0,i.kt)("p",null,"As your app ages, you'll probably write more migrations than you anticipated. The app I created Verdant for, Gnocchi, is up to version 34 of its schema at time of writing, and it's not even a year old."),(0,i.kt)("p",null,"This presents a problem: since we need to reconstruct the full version history to correctly resolve the historical migration changes, new users of the app have to run 34 migrations before they can get started! This can take a noticeable amount of time even though there is no actual data being migrated."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Why do we need to run all migrations? Why can't you just start from the latest schema?")," This is a consequence of how powerful I opted to make migrations in Verdant. In particular I wanted migrations to encapsulate the idea of seeding the database as well. In Gnocchi I seed the default grocery categories in the first migration. If I skipped it, those categories wouldn't exist.\nThis is a choice I made, perhaps you won't find the tradeoff worthwhile. But I think the compromise outlined in this section is sufficiently effective at mitigating the problems that the benefits are worth it.")),(0,i.kt)("p",null,'To circumvent having to apply every migration, you can define a "shortcut" migration which covers multiple version changes. For example, you can continuously update a shortcut migration from v1 to vCurrent for new users while maintaining all your existing migrations for previous users, basically the best of both worlds.'),(0,i.kt)("p",null,"However, you must do this carefully to have consistent experiences across all users. Particularly, if you seed data into the database or perform any side-effects (which is not recommended anyway), you'll need to replicate those in your shortcut migration for any migrations you skip over."),(0,i.kt)("p",null,"Define a shortcut migration by supplying a ",(0,i.kt)("inlineCode",{parentName:"p"},"from")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"to")," schema that are more than one version apart. Everything else is exactly the same. Verdant will take care of planning the most efficient route from the client's current version to the latest version using all of the migrations you supply."),(0,i.kt)("h3",{id:"deleting-old-migrations"},"Deleting old migrations"),(0,i.kt)("p",null,"Suppose you're confident nobody is using versions 1-10 of your schema anymore (be sure to actually measure this!). There's no use keeping those migrations in the codebase! If you're feeling some maintenance burden, or client code bundle size pain, you may wish to remove those old migrations and schemas."),(0,i.kt)("p",null,"This can be done, but you should be careful. Define a shortcut migration and only specify your new 'minimum schema':"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { migrate } from '@verdant-web/store';\nimport v11Schema from './schema-history/v11.js';\n\nexport default migrate(v11Schema, async ({ migrate }) => {\n    // write your shortcut logic here\n});\n")),(0,i.kt)("p",null,"Any data you want to seed should be in the shape of your target schema. If you have no seed data, the above is pretty much all you need."),(0,i.kt)("h4",{id:"handling-failures"},"Handling failures"),(0,i.kt)("p",null,"If you delete a migration, there's always a chance someone was on the version that needed it. For example, imagine you did the skip over 1-10 above, but one user was still on v6. If this happens, that user will not be able to initialize a Verdant client, and the app will hard crash on startup."),(0,i.kt)("p",null,"You should probably handle this case just to be safe. Catch any errors from ",(0,i.kt)("inlineCode",{parentName:"p"},"ClientDescriptor.open")," when you initialize your client. If a ",(0,i.kt)("inlineCode",{parentName:"p"},"MigrationPathError")," is thrown, that indicates that no valid path from the client's version to the latest version was found in your migrations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"try {\n    const client = await clientDescriptor.open();\n} catch (err) {\n    // I recommend using .name instead of instanceof because of\n    // module bundling pitfalls.\n    if (err.name === 'MigrationPathError') {\n        // time to figure out what to do.\n    }\n}\n")),(0,i.kt)("p",null,"There are a few options here: you could display an error screen and ask the user to contact you. From there you could push a code update which restores the necessary migrations for the user or create a new shortcut from their version to the latest."),(0,i.kt)("p",null,"Or, you could throw away the user's local storage. This is a bad experience if the user isn't utilizing sync (they just lose all their data). But if they are syncing, they may not even notice, since new data will populate automatically on reconnection to the server."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"if (err.name === 'MigrationPathError') {\n    // this will delete local storage contents\n    clientDescriptor.__dangerous__resetLocal();\n}\n")))}m.isMDXComponent=!0}}]);
"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7327],{369:(e,n,t)=>{t.d(n,{xA:()=>u,yg:()=>f});var r=t(7378);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},p="mdxType",y={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=l(t),d=o,f=p["".concat(s,".").concat(d)]||p[d]||y[d]||i;return t?r.createElement(f,a(a({ref:n},u),{},{components:t})):r.createElement(f,a({ref:n},u))}));function f(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=d;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c[p]="string"==typeof e?e:o,a[1]=c;for(var l=2;l<i;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},889:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>a,default:()=>y,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var r=t(8084),o=(t(7378),t(369));const i={sidebar_position:3},a="Connecting a Client",c={unversionedId:"sync/client",id:"sync/client",title:"Connecting a Client",description:"To connect your client to the server, you must pass it sync configuration.",source:"@site/docs/sync/client.md",sourceDirName:"sync",slug:"/sync/client",permalink:"/docs/sync/client",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Authenticating Sync",permalink:"/docs/sync/authentication"},next:{title:"Presence & Profiles",permalink:"/docs/sync/presence"}},s={},l=[{value:"Custom auth fetch",id:"custom-auth-fetch",level:2}],u={toc:l},p="wrapper";function y(e){let{components:n,...t}=e;return(0,o.yg)(p,(0,r.A)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.yg)("h1",{id:"connecting-a-client"},"Connecting a Client"),(0,o.yg)("p",null,"To connect your client to the server, you must pass it sync configuration."),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ts"},"import { ClientDescriptor, ServerSync } from './client/index.js';\nimport migrations from './migrations.js';\n\nconst clientDesc = new ClientDescriptor({\n    namespace: 'todos',\n    migrations,\n    sync: {\n        initialPresence: {\n            emoji: '',\n        },\n        defaultProfile: { name: '' },\n        authEndpoint: 'http://localhost:3000/auth/sync',\n    },\n});\n\nclientDesc.open().then((todos) => {\n    // now we have a todo data client, \"todos\"\n});\n")),(0,o.yg)("p",null,"You may also define typing for presence data:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-ts"},"export interface Presence {\n    emoji: string;\n}\n\nexport interface Profile {\n    // any data you may have put in profiles on the server\n}\n\nconst clientDesc = new ClientDescriptor<Presence, Profile>({\n    // ...\n});\n")),(0,o.yg)("p",null,"To start syncing, call ",(0,o.yg)("inlineCode",{parentName:"p"},"client.sync.start")," (where ",(0,o.yg)("inlineCode",{parentName:"p"},"client")," is your instance of Client, i.e. ",(0,o.yg)("inlineCode",{parentName:"p"},"todos")," above) This will connect to your websocket server. It's up to you to add any authentication and authorization to reject unregistered or unsubscribed clients if you want to limit access to sync. Verdant itself will sync whoever you let connect."),(0,o.yg)("p",null,"If you want to pause sync, call ",(0,o.yg)("inlineCode",{parentName:"p"},"client.sync.stop")," (where ",(0,o.yg)("inlineCode",{parentName:"p"},"client")," is your instance of Client, i.e. ",(0,o.yg)("inlineCode",{parentName:"p"},"todos")," above)."),(0,o.yg)("h2",{id:"custom-auth-fetch"},"Custom auth fetch"),(0,o.yg)("p",null,"By default the client will make a basic ",(0,o.yg)("inlineCode",{parentName:"p"},"fetch")," to your auth endpoint with ",(0,o.yg)("inlineCode",{parentName:"p"},"credentials: 'include'"),". If this endpoint is hosted on a server which your client already has a cookie session with, it should work out of the box."),(0,o.yg)("p",null,"If you use another solution for sessions, like a JWT in a header, you can pass in ",(0,o.yg)("inlineCode",{parentName:"p"},"fetchAuth")," instead of ",(0,o.yg)("inlineCode",{parentName:"p"},"authEndpoint")," to the sync configuration. This function must return a promise for the JSON response body of the authorization endpoint."))}y.isMDXComponent=!0}}]);
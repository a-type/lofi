"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[380],{369:(e,n,t)=>{t.d(n,{xA:()=>p,yg:()=>h});var o=t(7378);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,i=function(e,n){if(null==e)return{};var t,o,i={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=o.createContext({}),c=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},p=function(e){var n=c(e.components);return o.createElement(l.Provider,{value:n},e.children)},u="mdxType",y={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},d=o.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=c(t),d=i,h=u["".concat(l,".").concat(d)]||u[d]||y[d]||r;return t?o.createElement(h,a(a({ref:n},p),{},{components:t})):o.createElement(h,a({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,a=new Array(r);a[0]=d;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[u]="string"==typeof e?e:i,a[1]=s;for(var c=2;c<r;c++)a[c]=t[c];return o.createElement.apply(null,a)}return o.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6090:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>y,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var o=t(8084),i=(t(7378),t(369));const r={sidebar_position:2},a="Authenticating Sync",s={unversionedId:"sync/authentication",id:"sync/authentication",title:"Authenticating Sync",description:"To connect to sync, you must create an auth endpoint. This can be done automatically on the same server you use for sync, or you can define a custom endpoint on a different server.",source:"@site/docs/sync/authentication.md",sourceDirName:"sync",slug:"/sync/authentication",permalink:"/docs/sync/authentication",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Sync Server",permalink:"/docs/sync/server"},next:{title:"Connecting a Client",permalink:"/docs/sync/client"}},l={},c=[{value:"Additional token options",id:"additional-token-options",level:2},{value:"Token types",id:"token-types",level:3},{value:"Realtime vs. Push/Pull",id:"realtime-vs-pushpull",level:4},{value:"Passive",id:"passive",level:4},{value:"ReadOnly",id:"readonly",level:4}],p={toc:c},u="wrapper";function y(e){let{components:n,...t}=e;return(0,i.yg)(u,(0,o.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"authenticating-sync"},"Authenticating Sync"),(0,i.yg)("p",null,"To connect to sync, you must create an auth endpoint. This can be done automatically on the same server you use for sync, or you can define a custom endpoint on a different server."),(0,i.yg)("p",null,"Your endpoint must determine a ",(0,i.yg)("inlineCode",{parentName:"p"},"userId")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"libraryId")," for the connecting client and provide them to a ",(0,i.yg)("inlineCode",{parentName:"p"},"TokenProvider"),", then return the created access token and the sync endpoint URL as JSON."),(0,i.yg)("p",null,"Below is an example of a basic auth endpoint which gets a session for the request (according to custom logic you should provide)"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { Request, Response } from 'express';\nimport { TokenProvider } from '@verdant-web/server';\n\nconst tokenProvider = new TokenProvider({\n    // this must be the exact same secret as the one you supplied to Server\n    secret: process.env.LOFI_SECRET!,\n});\n\nasync function getLoginSession(req: Request) {\n    // here you would, say, read a cookie value and retrieve\n    // a session from a database, or decode a JWT.\n}\n\nfunction lofiHandler(req: Request, res: Response) {\n    const session = await getLoginSession(req);\n    if (!session) {\n        return res.status(401).send('Please log in');\n    }\n\n    // this is just one way to decide what library the user can\n    // sync to with this token. you might instead store\n    // the user's library in their session, or use their userId\n    // as a personal library ID. Library ID is up to you, but\n    // every user who is given access to the same library will\n    // be interacting with the same data!\n    const libraryId = req.params.libraryId;\n\n    // TODO: before creating at token, if your library ID was determined\n    // by a user-supplied value (such as our request param above),\n    // you should probably authorize access for the client user.\n\n    const token = tokenProvider.getToken({\n        userId: session.userId,\n        libraryId: session.planId,\n        // change this line to point to the correct host for your sync\n        // server. if you have multiple environments, this must take them\n        // into account.\n        syncEndpoint: `http://localhost:3000/sync`,\n        // additional token options are available. see below.\n    });\n\n    res.status(200).json({\n        accessToken: token,\n    });\n}\n")),(0,i.yg)("p",null,"This endpoint, wherever you choose to host it, will be supplied to the client to connect, authorize, and start syncing with your server."),(0,i.yg)("p",null,"Although it may seem cumbersome to have a separate endpoint for auth and sync, this flexibility allows you to host your main app server separately from your Verdant sync server, or even implement advanced architectures like spinning up a new server for each library."),(0,i.yg)("h2",{id:"additional-token-options"},"Additional token options"),(0,i.yg)("p",null,"More options can be specified to customize your token. These customizations can be very meaningful for client experience, so don't overlook this."),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"role"),": Provide your own role identifier for object-level authorization (TODO)"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"type"),": Specify a token type to change the client abilities and behavior in the syncing algorithm. See below."),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("inlineCode",{parentName:"li"},"expiresIn"),": Change how long the token is valid before a new one must be fetched. The client will automatically cache and refetch tokens based on expiry.")),(0,i.yg)("h3",{id:"token-types"},"Token types"),(0,i.yg)("p",null,"Token type determines how a replica client behaves with respect to sync transport and consensus."),(0,i.yg)("h4",{id:"realtime-vs-pushpull"},"Realtime vs. Push/Pull"),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Realtime")," token types allow live websocket subscription to changes."),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"Push"),"/",(0,i.yg)("inlineCode",{parentName:"p"},"Pull")," token types forbid realtime socket subscription and restrict the client to HTTP requests for syncing."),(0,i.yg)("h4",{id:"passive"},"Passive"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"Passive")," token types are second-class replicas with respect to consensus. The server and peers will not wait for these clients to acknowledge changes before compressing history. This means ",(0,i.yg)("strong",{parentName:"p"},"offline passive replicas lose changes.")," When a passive replica comes back online, any locally stored unapplied operations will be dropped. The flipside of this is that other peers don't need to wait for these replicas to come online and acknowledge operations to compress their history."),(0,i.yg)("p",null,"To illustrate, imagine a blog app where the owner of the blog can publish posts, and followers can comment on those posts."),(0,i.yg)("p",null,"All replicas controlled by the owner should have a non-",(0,i.yg)("inlineCode",{parentName:"p"},"Passive")," token type. That allows the owner to edit their posts offline with assurance that any of their devices will wait for all of their other devices to come online and acknowledge changes before history is compressed, which is key to conflict resolution if they draft things on multiple devices."),(0,i.yg)("p",null,"However, the number of followers could be very high, and they may not visit the blog very frequently. We wouldn't want to wait for every past visitor to the site to sign off on every change before compacting it down. So we can give visitors a ",(0,i.yg)("inlineCode",{parentName:"p"},"Passive")," token type, indicating we don't care if they get out of sync and have to reset on their next visit. In this example, that might mean that if a visitor tries to make a comment while offline, the comment could be lost, in theory (in practice, since no one else is editing your comment, it should not get 'left behind' and can merge in just fine)."),(0,i.yg)("h4",{id:"readonly"},"ReadOnly"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"ReadOnly")," tokens are like ",(0,i.yg)("inlineCode",{parentName:"p"},"Passive")," ones, but they also are denied the ability to submit any operations. They can only read the state, either ",(0,i.yg)("inlineCode",{parentName:"p"},"Realtime")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"Pull"),"."))}y.isMDXComponent=!0}}]);
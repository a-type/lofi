"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[188],{8570:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(79);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),p=d(n),m=i,h=p["".concat(s,".").concat(m)]||p[m]||c[m]||l;return n?a.createElement(h,o(o({ref:t},u),{},{components:n})):a.createElement(h,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,o=new Array(l);o[0]=p;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:i,o[1]=r;for(var d=2;d<l;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6202:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var a=n(7626),i=(n(79),n(8570));const l={sidebar_position:1},o="Why have a schema?",r={unversionedId:"local-storage/schema",id:"local-storage/schema",title:"Why have a schema?",description:"Verdant requires all data be defined in a schema. That may seem cumbersome, but knowing what data looks like is essential to changing the shape of that data over time as your app evolves. Data lives on user devices, not your servers, so getting migrations right is very important&mdash;data loss or corruption can be unrecoverable, and no backups exist.",source:"@site/docs/local-storage/schema.md",sourceDirName:"local-storage",slug:"/local-storage/schema",permalink:"/docs/local-storage/schema",draft:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Storing & Querying",permalink:"/docs/category/storing--querying"},next:{title:"Generating the client code",permalink:"/docs/local-storage/generate-client"}},s={},d=[{value:"Requirements for a schema",id:"requirements-for-a-schema",level:2},{value:"Requirements for a collection",id:"requirements-for-a-collection",level:2},{value:"Types of fields",id:"types-of-fields",level:2},{value:"<code>&#39;string&#39;</code>",id:"string",level:3},{value:"<code>&#39;number&#39;</code>",id:"number",level:3},{value:"<code>&#39;boolean&#39;</code>",id:"boolean",level:3},{value:"<code>&#39;array&#39;</code>",id:"array",level:3},{value:"<code>&#39;object&#39;</code>",id:"object",level:3},{value:"<code>&#39;map&#39;</code>",id:"map",level:3},{value:"<code>&#39;file&#39;</code>",id:"file",level:3},{value:"<code>&#39;any&#39;</code>",id:"any",level:3},{value:"Indexing Fields",id:"indexing-fields",level:2}],u={toc:d};function c(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"why-have-a-schema"},"Why have a schema?"),(0,i.kt)("p",null,"Verdant requires all data be defined in a schema. That may seem cumbersome, but knowing what data looks like is essential to changing the shape of that data over time as your app evolves. Data lives on user devices, not your servers, so getting migrations right is very important","\u2014","data loss or corruption can be unrecoverable, and no backups exist."),(0,i.kt)("p",null,"Take the time to think about how you model your data and define it in your schema. Mistakes in local-first apps are costly!"),(0,i.kt)("h1",{id:"creating-a-schema"},"Creating a schema"),(0,i.kt)("p",null,"The first step client-side is to define a schema of what kind of documents you are working with. A schema looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { collection, schema } from '@verdant-web/store';\n\nconst todoItems = collection({\n    name: 'todoItem',\n    // your primary key must be a field in your collection,\n    // and you must not rewrite it after creating a document.\n    primaryKey: 'id',\n    fields: {\n        id: {\n            type: 'string',\n            indexed: true,\n            unique: true,\n        },\n        details: {\n            type: 'string',\n            indexed: false,\n            unique: false,\n        },\n        done: {\n            type: 'boolean',\n        },\n    },\n    indexes: {},\n    compounds: {},\n});\n\nexport default schema({\n    version: 1,\n    collections: {\n        todoItems: todoItems,\n    },\n});\n")),(0,i.kt)("p",null,"This schema creates 1 document type, ",(0,i.kt)("inlineCode",{parentName:"p"},"todoItem"),", and defines some fields. It also creates the initial default migration to set up this schema in IndexedDB."),(0,i.kt)("p",null,"The TypeScript types for ",(0,i.kt)("inlineCode",{parentName:"p"},"collection")," should enforce proper schema shape, but the docs below explain what each part means."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: for now I recommend you define collections at the top level, like shown above, or even split them into their own modules. There's a problem with TypeScript typings if you define collections inline inside ",(0,i.kt)("inlineCode",{parentName:"p"},"schema()"),".")),(0,i.kt)("h2",{id:"requirements-for-a-schema"},"Requirements for a schema"),(0,i.kt)("p",null,"Each schema needs a ",(0,i.kt)("inlineCode",{parentName:"p"},"version"),". Whenever a change is made to the schema, the version must be incremented. Otherwise, Verdant will crash with an error."),(0,i.kt)("p",null,"Schemas also have a map of ",(0,i.kt)("inlineCode",{parentName:"p"},"collections"),". These define what kinds of documents are stored in your database."),(0,i.kt)("p",null,"Your schema can be multiple files, but the entry file (which you provide to the CLI) must have a default export which is a ",(0,i.kt)("inlineCode",{parentName:"p"},"schema()"),"."),(0,i.kt)("h2",{id:"requirements-for-a-collection"},"Requirements for a collection"),(0,i.kt)("p",null,"Each collection needs the following:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"name"),": a singular name for the collection."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"primaryKey"),": specify which field name acts as the primary document key. Must be a string or number field."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"fields"),": a map of root fields on the document. See below.")),(0,i.kt)("p",null,"Additionally, you can add complex indexes for querying the collection:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"indexes"),": freeform indexes which process the document into one indexed value (or an array of values) whenever it changes."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"compounds"),": multi-value indexes which let you query multiple field values at once. Advanced feature.")),(0,i.kt)("p",null,"See more on indexes ",(0,i.kt)("a",{parentName:"p",href:"/docs/local-storage/querying"},"here"),"."),(0,i.kt)("h2",{id:"types-of-fields"},"Types of fields"),(0,i.kt)("p",null,"Here's a list of field ",(0,i.kt)("inlineCode",{parentName:"p"},"type"),"s you can use in a collection, and their related options."),(0,i.kt)("h3",{id:"string"},(0,i.kt)("inlineCode",{parentName:"h3"},"'string'")),(0,i.kt)("p",null,"Defines a string field, as you'd expect."),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default: string | (() => string)"),": define a default value, or a function that returns a default value at create time.")),(0,i.kt)("h3",{id:"number"},(0,i.kt)("inlineCode",{parentName:"h3"},"'number'")),(0,i.kt)("p",null,"Defines a number field, as you'd expect."),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default: number | (() => number)"),": define a default value, or a function that returns a default value at create time.")),(0,i.kt)("h3",{id:"boolean"},(0,i.kt)("inlineCode",{parentName:"h3"},"'boolean'")),(0,i.kt)("p",null,"Defines a boolean field, as you'd expect."),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default: boolean | (() => boolean)"),": define a default value, or a function that returns a default value at create time.")),(0,i.kt)("h3",{id:"array"},(0,i.kt)("inlineCode",{parentName:"h3"},"'array'")),(0,i.kt)("p",null,"Defines an array/list field. These can also act as sets. Arrays always default to empty."),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"items: FieldSchema"),": a nested field schema definition which defines what each item in the array looks like."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," as a valid value for this field.")),(0,i.kt)("h3",{id:"object"},(0,i.kt)("inlineCode",{parentName:"h3"},"'object'")),(0,i.kt)("p",null,"Defines an object/record field. Objects always default to empty. Objects have statically-defined keys, each of which can have its own unique sub-schema. For maps where keys aren't known until runtime, see ",(0,i.kt)("inlineCode",{parentName:"p"},"'map'"),"."),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"properties: { [Key: string]: FieldSchema }"),": an object of key->value pairs, where values are nested field schema definitions which defines what kind of data exists on that key."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," as a valid value for this field.")),(0,i.kt)("h3",{id:"map"},(0,i.kt)("inlineCode",{parentName:"h3"},"'map'")),(0,i.kt)("p",null,"Defines a key-value map field, where keys are arbitrary and added at runtime, and values are given a known schema. Maps are never nullable and default empty."),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"values: FieldSchema"),": defines the sub-schema for values in the map.")),(0,i.kt)("h3",{id:"file"},(0,i.kt)("inlineCode",{parentName:"h3"},"'file'")),(0,i.kt)("p",null,"Defines a file field, which stores a file."),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"nullable: true"),": allows ",(0,i.kt)("inlineCode",{parentName:"li"},"null")," as a valid value for this field."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"downloadRemote: true"),": instructs the client to download and store file fields which are synced from other devices. By default, the client will instead load the file over the network. Using this is a tradeoff which enables offline file usage, but increases storage use.")),(0,i.kt)("h3",{id:"any"},(0,i.kt)("inlineCode",{parentName:"h3"},"'any'")),(0,i.kt)("p",null,"Opts out of schema checking for a field. An ",(0,i.kt)("inlineCode",{parentName:"p"},"any")," field can have nested data and can be used just like any other field, but no TypeScript types will be applied, and no runtime validation will occur (note: runtime validation doesn't currently exist, anyway...)"),(0,i.kt)("p",null,"Other options:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"default: any | (() => any)"),": define a default value for this field")),(0,i.kt)("h2",{id:"indexing-fields"},"Indexing Fields"),(0,i.kt)("p",null,"In earlier versions of Verdant, you could index a field by adding ",(0,i.kt)("inlineCode",{parentName:"p"},"indexed: true")," to it. To consolidate indexing, Verdant now requires all indexes to be specified in ",(0,i.kt)("inlineCode",{parentName:"p"},"indexes")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"compounds"),". There's a new index definition to easily index a single field (with typechecking): ",(0,i.kt)("inlineCode",{parentName:"p"},"{ field: 'fieldName' }"),", which you can use instead."))}c.isMDXComponent=!0}}]);